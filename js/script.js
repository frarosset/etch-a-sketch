let gridRows = 12;
let gridCols = 12;
let keepAR   = false;
let idealAR  = 1;
let penColor = thisAsFcn('black');
let backgroundColor = 'white';

/* DOM elements ---------------------------------------- */

let oneColorBtn    = document.querySelector('#oneColorBtn');
let randomColorBtn = document.querySelector('#randomColorBtn');
let gradientBtn    = document.querySelector('#gradientBtn');
let eraserBtn      = document.querySelector('#eraserBtn');
let clearGridBtn   = document.querySelector('#clearGridBtn');
let newGridBtn     = document.querySelector('#newGridBtn');

let nRowsSel = document.querySelector('#nRowsSel');
let nColsSel = document.querySelector('#nColsSel');
let nRowsLbl = document.querySelector('#nRowsLbl');
let nColsLbl = document.querySelector('#nColsLbl');

let keepARSel   = document.querySelector('#keepARSel');
let showGridSel = document.querySelector('#showGridSel');
let fixedARInfo = document.querySelector('#fixedARInfo');
let gridInfo    = document.querySelector('#gridInfo');

let oneColorSel = document.querySelector('#oneColorSel');

let grid     = document.querySelector('.grid');
let gridCnt  = document.querySelector('.grid-container');
let gridDivs; /* Array, generated dynamically */

/* Helper functions */

function removeDescendants(elem){
    while (elem.hasChildNodes()) {
        removeDescendants(elem.lastChild)
        elem.removeChild(elem.lastChild);
    }
}

function setBackgroundColor(elem,color){
    elem.style.backgroundColor = color;
}

function getBackgroundColor(elem){
    return elem.style.backgroundColor;
}

function setAspectRatio(elem, ar){
    elem.style.aspectRatio = ar;
}

function setPenColor(colorFcn){
    penColor = colorFcn;
}

function randomIntegerInRange(min=0,max=100){
    // Math.random() returns a number between 0 (inclusive) and 1 (exclusive)
    /* here min and max are assumed integer */
    //min = Math.ceil(min);
    //max = Math.floor(max);   
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// This is used to transform a variable to an anonymous function
// which only returns that variable.
// This will be used to select the color to use, which can be 
// selected only once (onecolor mode, where the color is indeed a
// variable, and thisAsFcn is used), or change at every grid cell
// (randomcolor mode, where the color is generated by an anonymous
// function).
function thisAsFcn(variable){
    return ()=>variable;
}

/* Grid creation */

function createGrid(gridRows,gridCols){

    deleteGrid();

    let gridAR = gridCols/gridRows;
    let gridCntAR = gridCnt.offsetWidth / gridCnt.offsetHeight;

    setAspectRatio(grid, gridAR);

    if (gridAR>=gridCntAR){
        gridCnt.style.flexDirection =  'row';  
    }else{
        gridCnt.style.flexDirection =  'column';  
    }   

    for (let i=0;i<gridRows;i++){
        let row = document.createElement('div');
        row.classList.add('rowOfGrid');
        for (let j=0; j<gridCols; j++){
            let cell = document.createElement('div');
            cell.classList.add('cellOfGrid');
            cell.classList.add('unselectable');
            cell.style.backgroundColor = 'white';
            cell.currentColor = cell.style.backgroundColor;

            cell.addEventListener("pointerdown",pointerDownCallback);
            cell.addEventListener('pointerenter',pointerEnterCallback);
            cell.addEventListener('pointerleave',pointerLeaveCallback);

            row.appendChild(cell);
        }
        grid.appendChild(row);
    }

    gridDivs = document.querySelectorAll('.cellOfGrid');

    if (showGridSel.value=='1'){
        showGrid();
    }

    updateGridInfo();
}


/* Settings interface*/

nRowsSel.addEventListener('input',(e) => {
    if (keepAR){
        gridRows = e.target.value;
        gridCols = Math.round(idealAR*gridRows);

        if (gridCols>e.target.max){
            gridCols=e.target.max;
            gridRows = Math.round(gridCols/idealAR);
            nRowsSel.value = gridRows;
        } else if (gridCols<e.target.min){
            gridCols=e.target.min;
            gridRows = Math.round(gridCols/idealAR);
            nRowsSel.value = gridRows;
        }

        nColsLbl.textContent = gridCols;
        nRowsLbl.textContent = gridRows;
        nColsSel.value = gridCols; 
    } else {  
        gridRows = e.target.value;
        nRowsLbl.textContent = gridRows;   
    }

    createGrid(gridRows,gridCols); 
});

nColsSel.addEventListener('input',(e) => {
    if (keepAR){
        gridCols = e.target.value;
        gridRows = Math.round(gridCols/idealAR);

        if (gridRows>e.target.max){
            gridRows=e.target.max;
            gridCols = Math.round(idealAR*gridRows);
            nColsSel.value = gridCols; 
        } else if (gridRows<e.target.min){
            gridRows=e.target.min;
            gridCols = Math.round(idealAR*gridRows);
            nColsSel.value = gridCols; 
        }

        nColsLbl.textContent = gridCols;
        nRowsLbl.textContent = gridRows;
        nRowsSel.value = gridRows; 
    } else {  
        gridCols = e.target.value;
        nColsLbl.textContent = gridCols;   
    }
    createGrid(gridRows,gridCols);  
});
   
keepARSel.addEventListener('input',(e) => {
    idealAR = gridCols/gridRows;
    keepAR = e.target.value=='1';

    updateFixedARInfo();
});


showGridSel.addEventListener('input',(e) => {
    if (e.target.value=='1'){
        showGrid();
    } else {
        hideGrid();
    }
});

function showGrid(){
    gridDivs.forEach(itm =>{
        itm.classList.add('showGrid');
    });    
}

function hideGrid(){
    gridDivs.forEach(itm =>{
        itm.classList.remove('showGrid');
    });    
}

function updateFixedARInfo(){
    let idealARToPrec = idealAR.toPrecision(2);
    let isApprox = idealAR != idealARToPrec;
    let strAR = keepAR?(isApprox?'∼':'') + idealARToPrec + ' ('+gridCols + ':' + gridRows + ')': 'none';
    fixedARInfo.textContent = strAR;
}

function updateGridInfo(){
    let gridAR = gridCols/gridRows;
    let gridARToPrec = gridAR.toPrecision(2);
    let isApprox = gridAR != gridARToPrec;
    let strAR = gridCols + 'x' + gridRows + ' (AR: ' + (isApprox?'∼':'') + gridARToPrec + ')';
    gridInfo.textContent = strAR;
}

/* One color mode ---------------------------------------------------------- */

// The following behaviour is imposed:
//
// - If the user is using a mouse, hovering on an cell just temporarly set the 
//   color of the cell to the selected one. The change is permanent only if a 
//   left click occurs in such cell, or the left mouse button is pressed when 
//   the pointer either enters  or leaves it. Otherwise, the previous color 
//   (cell.currentColor) is restored once the mouse leaves.
//
// - If the user is using touch, the changes are always permanent when
//   a touch or a slide occur.
// 
// To implement this behaviour, the 'pointerenter' and 'pointerleave' events can 
// be used.
// See https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter
//
// Note that PointerDown events are fired when a left/right/middle mouse buttons 
// are pressed or a touch occurs. This causes the element to 'capture' the pointer, 
// preventing further pointerleave/enter events unless the capture is explicitly 
// released. Then, it is necessary to call the method releasePointerCapture(e.pointerId)
// when a pointerdown event occurs.
//
// The CSS attributes 'touch-action: none;' and 'user-select: none;' 
// must be added to the .cellOfGrid elements, in order to avoid default 
// touch iterations and selections of such cells.
//
// See the buttons code here: https://w3c.github.io/pointerevents/#the-buttons-property
// In particular, a touch event/sliding or a mouse moving with left buttons pressed 
// are coded by event.buttons=='1'. There is no need to test for event.pointerType
//
// .ColorSetOnEnterOrDown  is a property of each grid cell needed when the 
// applied color varies  as the pointer moves. In particular,
// - touch: at each tap or when sliding in, a new color is generated, and
//          permanently applied.
// - mouse: a new color is generated, and permanently applied at each right
//          click on the cell, provided that a new color has already been
//          permanentely applied since the mouse entered the cell. Otherwise,
//          the the background color is permanently applied.
// .ColorSetOnEnterOrDown is set to true when the color is permanent applied
// to a cell, and restored to false when the mouse leaves it.

function pointerDownCallback(e){
    let cell = e.target;
    if (cell.ColorSetOnEnterOrDown){
        cell.currentColor = penColor();
    } else {
        cell.currentColor = getBackgroundColor(cell);
        cell.ColorSetOnEnterOrDown = true;
    }
    setBackgroundColor(cell,cell.currentColor);
    cell.releasePointerCapture(e.pointerId); // Important! (see above)
}

function pointerEnterCallback(e){
    let cell = e.target;
    let color = penColor();
    //console.log(e.pointerType);
    if (e.buttons=='1'){
        // mouse enters with (only) left button pressed 
        // or touch slide-in
        cell.currentColor = color;
        cell.ColorSetOnEnterOrDown = true;
    } else {
        // mouse enter without (only) left button pressed 
        cell.ColorSetOnEnterOrDown = false;
    }
    setBackgroundColor(cell,color);
}

function pointerLeaveCallback(e){
    let cell = e.target;
    cell.ColorSetOnEnterOrDown = false;
    setBackgroundColor(cell,cell.currentColor);
}






/* Grid Functions*/
function clearGrid(){
    gridDivs.forEach(itm =>{
        itm.currentColor = backgroundColor;
        setBackgroundColor(itm,backgroundColor);
    });
}

function deleteGrid(){
    removeDescendants(grid);
    gridDivs = [];
}


/* Mode Buttons Functions */

function selectBtn(btn){
    currentBtn.classList.remove('activeBtn');
    currentBtn = btn;
    currentBtn.classList.add('activeBtn');
}

function clickBtnCallback(e){
    selectBtn(e.target);
}

/* One color mode */
function oneColorBtnCallback(e){
    setPenColor(thisAsFcn(oneColorSel.value));
}

function oneColorSelCallback(e){
    setPenColor(thisAsFcn(oneColorSel.value));
}

/* Random color mode */
let generateRandomColor = () => {
    let H = randomIntegerInRange(0,359); /* 0 === 360 */
    let S = randomIntegerInRange(20,100);
    let L = randomIntegerInRange(20,80);
    return `hsl(${H},${S}%,${L}%)`;
}

function randomColorBtnCallback(e){
    setPenColor(generateRandomColor);
}


/* Eraser mode */
function eraserBtnCallback(e){
    setPenColor(thisAsFcn(backgroundColor));
}

/* Clear grid  */
function clearGridBtnCallback(e){
    clearGrid();
}



/* Add event listeners --------------------------------- */

document.querySelectorAll("button.mutuallyExclusiveBtn").forEach(itm => {
    itm.addEventListener("click", clickBtnCallback)
});


oneColorBtn.addEventListener("click", oneColorBtnCallback);
oneColorSel.addEventListener('input', oneColorSelCallback);

randomColorBtn.addEventListener("click", randomColorBtnCallback);

eraserBtn.addEventListener("click", eraserBtnCallback);

clearGridBtn.addEventListener("click", clearGridBtnCallback);






// TODO  
//  randomColorBtn 
//  gradientBtn     
//  newGridBtn     




/* Initialization -------------------------------------- */
let currentBtn = oneColorBtn;
selectBtn(oneColorBtn);

createGrid(gridRows,gridCols);